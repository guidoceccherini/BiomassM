EU_crs <- crs(disturbance_eu_vrt)
# EEA_forest_type_cropped <- crop(forest_type_vrt, EU_extent)
# rcl_matrix <- matrix(c(
#   0, NA,    # all non-tree and non-forest areas -> NA (or use 0 if you want to keep it)
#   1, 1,     # broadleaved forest -> 1 (Broadleaf)
#   2, 2,     # coniferous forest -> 2 (Needleleaf)
#   3, 3,     # mixed forest -> 3 (Mixed Forest)
#   254, NA,  # unclassifiable -> NA
#   255, NA   # outside area -> NA
# ), ncol = 2, byrow = TRUE)
#
# EEA_forest_type_cropped <- classify(EEA_forest_type_cropped, rcl_matrix)
#
# terra::writeRaster(EEA_forest_type_cropped,
#             "Data/EEA_forest_type_cropped_EU.tif",
#             overwrite = TRUE,
#             gdal = c("COMPRESS=LZW", "TILED=YES"))
EEA_forest_type_cropped <- rast("Data/EEA_forest_type_cropped_EU.tif")
# check extents
# Per biomass con ricampionamento bilinear
# Estrai i parametri come valori numerici singoli
ref_ext <- ext(disturbance_eu_vrt)
ref_res <- res(disturbance_eu_vrt)
ref_crs <- crs(disturbance_eu_vrt, proj=TRUE)
# sf::gdal_utils(
#   util = "warp",
#   source = 'NETCDF:"Data/ESACCI-BIOMASS-L4-AGB-MERGED-100m-2010-fv6.0.nc":agb',  # sostituisci 'agb' con il nome corretto
#   destination = "Data/Biomass2010_alignedEU.tif",
#   options = c(
#     "-t_srs", crs(disturbance_eu_vrt, proj=TRUE),
#     "-te", sprintf("%.6f", ref_ext[1]), sprintf("%.6f", ref_ext[3]),
#     sprintf("%.6f", ref_ext[2]), sprintf("%.6f", ref_ext[4]),
#     "-tr", sprintf("%.6f", ref_res[1]), sprintf("%.6f", ref_res[2]),
#     "-r", "bilinear",
#     "-multi",
#     "-wo", "NUM_THREADS=ALL_CPUS",
#     "-co", "COMPRESS=LZW",
#     "-co", "TILED=YES",
#     "-co", "BIGTIFF=YES"
#   )
# )
Biomass2010_aligned <- rast("Data/Biomass2010_alignedEU.tif")
ref_ext <- as.vector(ext(disturbance_eu_vrt))
ref_res <- res(disturbance_eu_vrt)
# sf::gdal_utils(
#   util = "warp",
#   source = "Data/EEA_forest_type_cropped_EU.tif",  # modifica il path se necessario
#   destination = "Data/EEA_forest_type_alignedEU.tif",
#   options = c(
#     "-t_srs", crs(disturbance_eu_vrt, proj=TRUE),
#     "-te", sprintf("%.6f", ref_ext[1]), sprintf("%.6f", ref_ext[3]),
#     sprintf("%.6f", ref_ext[2]), sprintf("%.6f", ref_ext[4]),
#     "-tr", sprintf("%.6f", ref_res[1]), sprintf("%.6f", ref_res[2]),
#     "-r", "near",  # nearest neighbor per dati categorici
#     "-multi",
#     "-wo", "NUM_THREADS=ALL_CPUS",
#     "-co", "COMPRESS=LZW",
#     "-co", "TILED=YES",
#     "-co", "BIGTIFF=YES"
#   )
# )
# Ricarica i risultati in terra
EEA_forest_type_aligned <- rast("Data/EEA_forest_type_alignedEU.tif")
#
# Biomass2010_reprojected <- project(biomass_vrt[[1]],
#                                    disturbance_eu_vrt,
#                                    method = "bilinear")
# If EEA_forest_type is also in different CRS, reproject it
# EEA_forest_type_reprojected <- project(EEA_forest_type_cropped,
#                                        disturbance_eu_vrt,
#                                        method = "near")  # Use "near" for categorical data
# Step 2: Resample to match exact grid alignment
# This ensures pixels align perfectly
# Biomass2010_aligned <- resample(Biomass2010_reprojected,
#                                 disturbance_binary,
#                                 method = "bilinear")
#
# EEA_forest_type_aligned <- resample(EEA_forest_type_reprojected,
#                                     disturbance_binary,
#                                     method = "near")
# Verify they now match
compareGeom(disturbance_eu_vrt, Biomass2010_aligned, EEA_forest_type_aligned)
# Stack all together
eu_stack <- c(Biomass2010_aligned, undisturbed_eu_vrt, EEA_forest_type_aligned)
names(eu_stack) <- c("biomass", "undisturbed", "forest_type")
# Load EU hexagon grid
Hex_EU <- st_read("Data/grid_forest.gpkg")
Hex_EU <- Hex_EU|> dplyr::filter(forest_count >0)
# Reproject if needed
if(st_crs(Hex_EU) != st_crs(eu_stack)) {
Hex_EU <- st_transform(Hex_EU, st_crs(eu_stack))
}
# Add hex ID
if(!"hex_ID" %in% names(Hex_EU)) {
Hex_EU$hex_ID <- 1:nrow(Hex_EU)
}
install.packages("future.apply")
install.packages("progressr")
library(future.apply)
library(progressr)
library(data.table)
# Setup
plan(multisession, workers = availableCores() - 1)
n_cores <- availableCores() - 1
hex_groups <- split(1:nrow(Hex_EU), cut(1:nrow(Hex_EU), n_cores, labels = FALSE))
# Funzione con progress tracking
process_hex_group_progress <- function(hex_indices, hex_sf, raster_stack) {
library(terra)
library(data.table)
p <- progressor(along = hex_indices)
group_results <- vector("list", length(hex_indices))
for(i in seq_along(hex_indices)) {
idx <- hex_indices[i]
tryCatch({
hex_vals <- extract(raster_stack, hex_sf[idx, ], ID = FALSE)
dt <- data.table(hex_vals)
dt <- dt[!is.na(undisturbed) & undisturbed == 1 &
!is.na(biomass) & biomass > 0 &
!is.na(forest_type) & forest_type %in% c(1, 2, 3)]
if(nrow(dt) > 0) {
dt[, hex_ID := hex_sf$hex_ID[idx]]
group_results[[i]] <- dt
}
}, error = function(e) NULL)
p()  # aggiorna progress
}
return(rbindlist(group_results[!sapply(group_results, is.null)]))
}
# Esegui con progress bar
cat("Processing", nrow(Hex_EU), "hexagons in parallel...\n")
with_progress({
all_results <- future_lapply(
hex_groups,
process_hex_group_progress,
hex_sf = Hex_EU,
raster_stack = eu_stack,
future.seed = TRUE
)
})
final_dt <- rbindlist(all_results)
plan(sequential)
final_dt
Hex_EU
eu_stack
EEA_forest_type_aligned
plot(EEA_forest_type_aligned)
library(future.apply)
library(progressr)
library(data.table)
# Setup
plan(multisession, workers = availableCores() - 1)
n_cores <- availableCores() - 1
hex_groups <- split(1:nrow(Hex_EU), cut(1:nrow(Hex_EU), n_cores, labels = FALSE))
hex_groups
# Funzione con progress tracking
process_hex_group_progress <- function(hex_indices, hex_sf, raster_stack) {
library(terra)
library(data.table)
p <- progressor(along = hex_indices)
group_results <- vector("list", length(hex_indices))
for(i in seq_along(hex_indices)) {
idx <- hex_indices[i]
tryCatch({
hex_vals <- extract(raster_stack, hex_sf[idx, ], ID = FALSE)
dt <- data.table(hex_vals)
dt <- dt[!is.na(undisturbed) & undisturbed == 1 &
!is.na(biomass) & biomass > 0 &
!is.na(forest_type) & forest_type %in% c(1, 2, 3)]
if(nrow(dt) > 0) {
dt[, hex_ID := hex_sf$hex_ID[idx]]
group_results[[i]] <- dt
}
}, error = function(e) NULL)
p()  # aggiorna progress
}
return(rbindlist(group_results[!sapply(group_results, is.null)]))
}
# Esegui con progress bar
cat("Processing", nrow(Hex_EU), "hexagons in parallel...\n")
with_progress({
all_results <- future_lapply(
hex_groups,
process_hex_group_progress,
hex_sf = Hex_EU,
raster_stack = eu_stack,
future.seed = TRUE
)
})
final_dt <- rbindlist(all_results)
plan(sequential)
library(future.apply)
library(data.table)
# Setup parallelizzazione
plan(multisession, workers = availableCores() - 1)  # lascia 1 core libero
# Dividi gli hexagoni in gruppi (uno per core)
n_cores <- availableCores() - 1
hex_groups <- split(1:nrow(Hex_EU), cut(1:nrow(Hex_EU), n_cores, labels = FALSE))
# Funzione per processare un gruppo di hexagoni
process_hex_group <- function(hex_indices, hex_sf, raster_stack) {
library(terra)
library(data.table)
group_results <- vector("list", length(hex_indices))
for(i in seq_along(hex_indices)) {
idx <- hex_indices[i]
tryCatch({
hex_vals <- extract(raster_stack, hex_sf[idx, ], ID = FALSE)
dt <- data.table(hex_vals)
# Filter
dt <- dt[!is.na(undisturbed) & undisturbed == 1 &
!is.na(biomass) & biomass > 0 &
!is.na(forest_type) & forest_type %in% c(1, 2, 3)]
if(nrow(dt) > 0) {
dt[, hex_ID := hex_sf$hex_ID[idx]]
group_results[[i]] <- dt
}
}, error = function(e) NULL)
}
return(rbindlist(group_results[!sapply(group_results, is.null)]))
}
# Esegui in parallelo
cat("Processing", nrow(Hex_EU), "hexagons in parallel on", n_cores, "cores...\n")
all_results <- future_lapply(
hex_groups,
process_hex_group,
hex_sf = Hex_EU,
raster_stack = eu_stack,
future.seed = TRUE
)
# Combina i risultati
final_dt <- rbindlist(all_results)
# Chiudi parallelizzazione
plan(sequential)
sequential
final_dt
# Stack all together
eu_stack <- c(Biomass2010_aligned, undisturbed_eu_vrt, EEA_forest_type_aligned)
names(eu_stack) <- c("biomass", "undisturbed", "forest_type")
# Load EU hexagon grid
Hex_EU <- st_read("Data/grid_forest.gpkg")
Hex_EU <- Hex_EU|> dplyr::filter(forest_count >0)
# Reproject if needed
if(st_crs(Hex_EU) != st_crs(eu_stack)) {
Hex_EU <- st_transform(Hex_EU, st_crs(eu_stack))
}
# Add hex ID
if(!"hex_ID" %in% names(Hex_EU)) {
Hex_EU$hex_ID <- 1:nrow(Hex_EU)
}
# Extract function
extract_hex_data <- function(hex_idx, hex_geom, raster_stack) {
tryCatch({
hex_vals <- extract(raster_stack, hex_geom, ID = FALSE)
dt <- data.table(hex_vals)
# Filter: only undisturbed pixels with valid forest type and biomass
dt <- dt[!is.na(undisturbed) & undisturbed == 1 &
!is.na(biomass) & biomass > 0 &
!is.na(forest_type) & forest_type %in% c(1, 2, 3)]
if(nrow(dt) > 0) {
dt[, hex_ID := hex_idx]
return(dt)
} else {
return(NULL)
}
}, error = function(e) {
return(NULL)
})
}
# Process all hexagons
cat("Processing", nrow(Hex_EU), "hexagons across EU...\n")
all_results <- vector("list", nrow(Hex_EU))
test <- extract_hex_data(Hex_EU$hex_ID[11],
Hex_EU[11, ],
eu_stack)
test
test
View(test)
for(i in 1:nrow(Hex_EU)) {
if(i %% 1000 == 0) {
cat(sprintf("[%s] Hexagon %d/%d (%.1f%%)\n",
Sys.time(), i, nrow(Hex_EU), 100*i/nrow(Hex_EU)))
gc()
}
all_results[[i]] <- extract_hex_data(Hex_EU$hex_ID[i],
Hex_EU[i, ],
eu_stack)
}
library(exactextractr)
library(data.table)
library(exactextractr)
library(data.table)
chunk_size <- 1000  # Ajusta based on your RAM
n_chunks <- ceiling(nrow(Hex_EU) / chunk_size)
all_results <- list()
for(i in 1:n_chunks) {
cat(sprintf("[%s] Processing chunk %d/%d\n", Sys.time(), i, n_chunks))
# Select chunk
start_idx <- (i-1) * chunk_size + 1
end_idx <- min(i * chunk_size, nrow(Hex_EU))
hex_chunk <- Hex_EU[start_idx:end_idx, ]
# Extract with summary function
chunk_result <- exact_extract(eu_stack, hex_chunk,
fun = function(df) {
dt <- as.data.table(df)
dt <- dt[!is.na(undisturbed) & undisturbed == 1 &
!is.na(biomass) & biomass > 0 &
!is.na(forest_type) & forest_type %in% c(1, 2, 3)]
if(nrow(dt) == 0) return(data.table())
dt[, .(
mean_biomass = mean(biomass),
median_biomass = median(biomass),
q25_biomass = quantile(biomass, 0.25),
q75_biomass = quantile(biomass, 0.75),
n_pixels = .N
), by = forest_type]
},
include_cols = "hex_ID",
summarize_df = TRUE,
max_cells_in_memory = 3e7)
all_results[[i]] <- chunk_result
rm(chunk_result)
gc()
}
final_data
final_data <- rbindlist(all_results)
final_data
for(i in 1:n_chunks) {
cat(sprintf("[%s] Chunk %d/%d\n", Sys.time(), i, n_chunks))
start_idx <- (i-1) * chunk_size + 1
end_idx <- min(i * chunk_size, nrow(Hex_EU))
hex_chunk <- Hex_EU[start_idx:end_idx, ]
chunk_bbox <- st_bbox(hex_chunk)
chunk_ext <- ext(chunk_bbox[c("xmin", "xmax", "ymin", "ymax")])
buffer <- 10000
chunk_ext_buffered <- chunk_ext + buffer
eu_stack_cropped <- crop(eu_stack, chunk_ext_buffered)
# Use a function that preserves hex_ID from include_cols
chunk_result <- exact_extract(eu_stack_cropped, hex_chunk,
fun = function(df) {
dt <- as.data.table(df)
# hex_ID is included in df due to include_cols
hex_id <- dt$hex_ID[1]  # All rows have same hex_ID
dt <- dt[!is.na(undisturbed) & undisturbed == 1 &
!is.na(biomass) & biomass > 0 &
!is.na(forest_type) & forest_type %in% c(1, 2, 3)]
if(nrow(dt) == 0) return(data.table())
stats <- dt[, .(
mean_biomass = mean(biomass),
median_biomass = median(biomass),
q25_biomass = quantile(biomass, 0.25),
q75_biomass = quantile(biomass, 0.75),
n_pixels = .N
), by = forest_type]
stats[, hex_ID := hex_id]
return(stats)
},
include_cols = "hex_ID",
summarize_df = TRUE,
max_cells_in_memory = 5e7)
all_results[[i]] <- chunk_result
rm(eu_stack_cropped, chunk_result)
gc()
}
# Combine all chunks
final_data <- rbindlist(all_results)
final_data
write_csv(final_data, "Data/biomass_EU_by_hexagon_undisturbed_v2.csv")
disturbance_eu_vrt
# same for disturbed
eu_stack <- c(Biomass2010_aligned, disturbance_eu_vrt, EEA_forest_type_aligned)
names(eu_stack) <- c("biomass", "undisturbed", "forest_type")
chunk_size <- 1000
n_chunks <- ceiling(nrow(Hex_EU) / chunk_size)
all_results <- list()
eu_stack
for(i in 1:n_chunks) {
cat(sprintf("[%s] Chunk %d/%d\n", Sys.time(), i, n_chunks))
start_idx <- (i-1) * chunk_size + 1
end_idx <- min(i * chunk_size, nrow(Hex_EU))
hex_chunk <- Hex_EU[start_idx:end_idx, ]
chunk_bbox <- st_bbox(hex_chunk)
chunk_ext <- ext(chunk_bbox[c("xmin", "xmax", "ymin", "ymax")])
buffer <- 10000
chunk_ext_buffered <- chunk_ext + buffer
eu_stack_cropped <- crop(eu_stack, chunk_ext_buffered)
# Use a function that preserves hex_ID from include_cols
chunk_result <- exact_extract(eu_stack_cropped, hex_chunk,
fun = function(df) {
dt <- as.data.table(df)
# hex_ID is included in df due to include_cols
hex_id <- dt$hex_ID[1]  # All rows have same hex_ID
dt <- dt[!is.na(undisturbed) & undisturbed == 1 &
!is.na(biomass) & biomass > 0 &
!is.na(forest_type) & forest_type %in% c(1, 2, 3)]
if(nrow(dt) == 0) return(data.table())
stats <- dt[, .(
mean_biomass = mean(biomass),
median_biomass = median(biomass),
q25_biomass = quantile(biomass, 0.25),
q75_biomass = quantile(biomass, 0.75),
n_pixels = .N
), by = forest_type]
stats[, hex_ID := hex_id]
return(stats)
},
include_cols = "hex_ID",
summarize_df = TRUE,
max_cells_in_memory = 5e7)
all_results[[i]] <- chunk_result
rm(eu_stack_cropped, chunk_result)
gc()
}
final_data <- rbindlist(all_results)
write_csv(final_data, "Data/biomass_EU_by_hexagon_disturbed_v2.csv")
library(sf)
library(raster)
library(tidyverse)
library(tmap)
library(ggplot2)
library("stringr")
library(scales)
library(ggspatial)
library(colorblindcheck)
library(rcartocolor)
library(cols4all)
library(ggpubfigs)
library(tidyverse)
library(jsonlite)
library(terra)
library(data.table)
biomass_hex_UND <- read_csv("Data/biomass_EU_by_hexagon_undisturbed_v2.csv")
biomass_hex_DIST <- read_csv("Data/biomass_EU_by_hexagon_disturbed_v2.csv")
setDT(biomass_hex_UND)
setDT(biomass_hex_DIST)
# 2. Summary statistics by hexagon and forest type
hex_summary_UND <- biomass_hex_UND[, .(
n_pixels = .N,
mean_biomass = mean(biomass),
median_biomass = median(biomass),
sd_biomass = sd(biomass),
min_biomass = min(biomass),
max_biomass = max(biomass)
# total_biomass = sum(biomass)
), by = .(hex_ID, forest_type_label)]
biomass_hex_UND
# convert to tibbles
hex_summary_UND <- as_tibble(biomass_hex_UND)
hex_summary_DIST <- as_tibble(biomass_hex_DIST)
# add columns to identify disturbed vs undisturbed
hex_summary_UND <- hex_summary_UND %>%
mutate(disturbance_status = "Undisturbed")
hex_summary_DIST <- hex_summary_DIST %>%
mutate(disturbance_status = "Disturbed")
# combine both summaries
hex_summary <- bind_rows(hex_summary_UND, hex_summary_DIST)
hex_summary
hex_summary_ratio <- hex_summary %>%
filter(n_pixels >= 30) %>%
select(hex_ID, forest_type, mean_biomass, disturbance_status) %>%
pivot_wider(names_from = disturbance_status, values_from = mean_biomass) %>%
mutate(biomass_ratio_DIST_UND = Disturbed / Undisturbed)
hex_summary_ratio
hex_summary_ratio <- hex_summary %>%
filter(n_pixels >= 30) %>%
select(hex_ID, forest_type, mean_biomass, disturbance_status) %>%
pivot_wider(names_from = disturbance_status, values_from = mean_biomass) %>%
mutate(biomass_ratio_DIST_UND = Disturbed / Undisturbed)
# make hex_summary_ratio wider to get forest type in wide format
hex_summary_ratio_wide <- hex_summary_ratio %>%
select(hex_ID, forest_type, biomass_ratio_DIST_UND) %>%
pivot_wider(names_from = forest_type_label, values_from = biomass_ratio_DIST_UND, names_prefix = "ratio_")
# make hex_summary_ratio wider to get forest type in wide format
hex_summary_ratio_wide <- hex_summary_ratio %>%
select(hex_ID, forest_type, biomass_ratio_DIST_UND) %>%
pivot_wider(names_from = forest_type, values_from = biomass_ratio_DIST_UND, names_prefix = "ratio_")
# make hex_summary_ratio wider to get forest type in wide format
hex_summary_Undisturbed_wide <- hex_summary_ratio %>%
select(hex_ID, forest_type, Undisturbed) %>%
pivot_wider(names_from = forest_type, values_from = Undisturbed, names_prefix = "UND_")
hex_summary_Disturbed_wide <- hex_summary_ratio %>%
select(hex_ID, forest_type, Disturbed) %>%
pivot_wider(names_from = forest_type, values_from = Disturbed, names_prefix = "DIST_")
Hex_italy <- st_read('Data/grids/grid_forest.gpkg')
Hex_italy <- st_read('Data/grid_forest.gpkg')
Hex_EU <- Hex_EU|> dplyr::filter(forest_count >0)
Hex_EU <- st_read('Data/grid_forest.gpkg')
Hex_EU <- Hex_EU|> dplyr::filter(forest_count >0)
# Reproject if needed
if(st_crs(Hex_EU) != st_crs(eu_stack)) {
Hex_EU <- st_transform(Hex_EU, st_crs(eu_stack))
}
# Add hex ID
if(!"hex_ID" %in% names(Hex_EU)) {
Hex_EU$hex_ID <- 1:nrow(Hex_EU)
}
# join hex_summary_ratio with Hex_italy
Hex_italy_biomass_ratio <- Hex_EU %>% ###st_drop_geometry() %>%
left_join(hex_summary_ratio_wide, by = c("hex_ID")) %>%
left_join(hex_summary_Undisturbed_wide, by = c("hex_ID"))%>%
left_join(hex_summary_Disturbed_wide, by = c("hex_ID"))
# write Hex_italy_biomass_ratio to gpkg
st_write(Hex_EU_biomass_ratio, "Data/Hexs/Hex_EU_biomass_ratioUndisturbed.gpkg", delete_dsn = TRUE)
# join hex_summary_ratio with Hex_italy
Hex_EU_biomass_ratio <- Hex_EU %>% ###st_drop_geometry() %>%
left_join(hex_summary_ratio_wide, by = c("hex_ID")) %>%
left_join(hex_summary_Undisturbed_wide, by = c("hex_ID"))%>%
left_join(hex_summary_Disturbed_wide, by = c("hex_ID"))
# write Hex_italy_biomass_ratio to gpkg
st_write(Hex_EU_biomass_ratio, "Data/Hexs/Hex_EU_biomass_ratioUndisturbed.gpkg", delete_dsn = TRUE)
Hex_EU_biomass_ratio
Hex_EU_biomass_ratio <- Hex_EU_biomass_ratio |> dplyr::select(-hex_ID)
# write Hex_italy_biomass_ratio to gpkg
st_write(Hex_EU_biomass_ratio, "Data/Hexs/Hex_EU_biomass_ratioUndisturbed.gpkg", delete_dsn = TRUE)
